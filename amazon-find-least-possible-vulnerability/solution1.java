
import java.util.*;

public class Main {
    static int n;
    static int[] key;
    static int[] seg;   // segment tree for gcd

    public static void main(String[] args) {
        // Existing Sample Case 1
        runTest(new int[]{2, 2, 4, 9, 6}, 1, 2);

        // Existing Sample Case 2
        runTest(new int[]{5, 10, 20, 10, 15, 5}, 2, 2);

        // Existing Sample Case 3
        runTest(new int[]{4, 2, 4}, 1, 1);

        // New Sample Case 4
        runTest(new int[]{3, 5, 7, 11, 13}, 2, 0);
    }

    static void runTest(int[] arr, int maxChange, int expected) {
        key = arr;
        n = key.length;
        buildGCDSegmentTree();
        int ans = findVulnerabilityFactor(maxChange);
        System.out.printf("Input: arr = %s, k = %d%n", Arrays.toString(arr), maxChange);
        System.out.printf("Output: %d  (expected: %d)%n%n", ans, expected);
    }

    // Binary-search answer in [1..n], with a special case for 0
    static int findVulnerabilityFactor(int maxChange) {
        // ----- NEW PRECHECK -----
        // If there is NO adjacent pair with gcd>1, then no length-2+ subarray ever has gcd>1,
        // so the answer is 0 regardless of k.
        boolean hasBadPair = false;
        for (int i = 0; i + 1 < n; i++) {
            if (gcd(key[i], key[i+1]) > 1) {
                hasBadPair = true;
                break;
            }
        }
        if (!hasBadPair) {
            return 0;
        }
        // ----- END PRECHECK -----

        int lo = 1, hi = n, ans = n;
        while (lo <= hi) {
            int mid = (lo + hi) >>> 1;
            if (canAchieve(mid, maxChange)) {
                ans = mid;
                hi  = mid - 1;
            } else {
                lo  = mid + 1;
            }
        }
        return ans;
    }

    // Check if we can make "no GCD>1 subarray of length > T" with ≤ maxChange edits
    static boolean canAchieve(int T, int maxChange) {
        List<int[]> intervals = new ArrayList<>();
        // we only consider windows of length T+1 ≥ 2:
        if (T + 1 >= 2) {
            for (int i = 0; i + T < n; i++) {
                if (rangeGCD(i, i + T) > 1) {
                    intervals.add(new int[]{i, i + T});
                }
            }
        }
        if (intervals.isEmpty()) return true;

        intervals.sort(Comparator.comparingInt(a -> a[1]));
        int used = 0, lastCovered = -1;
        for (int[] iv : intervals) {
            if (iv[0] <= lastCovered) continue;
            used++;
            lastCovered = iv[1];
            if (used > maxChange) return false;
        }
        return true;
    }

    // --- Segment-tree for GCD on [0..n-1] ---
    static void buildGCDSegmentTree() {
        seg = new int[4 * n];
        build(1, 0, n - 1);
    }
    static void build(int node, int l, int r) {
        if (l == r) {
            seg[node] = key[l];
        } else {
            int m = (l + r) >>> 1;
            build(node<<1,     l,   m);
            build(node<<1|1, m+1,   r);
            seg[node] = gcd(seg[node<<1], seg[node<<1|1]);
        }
    }
    static int rangeGCD(int L, int R) {
        return query(1, 0, n - 1, L, R);
    }
    static int query(int node, int l, int r, int L, int R) {
        if (R < l || r < L) return 0;
        if (L <= l && r <= R) return seg[node];
        int m = (l + r) >>> 1;
        int left  = query(node<<1,     l,   m, L, R);
        int right = query(node<<1|1, m+1,   r, L, R);
        return gcd(left, right);
    }
    static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
