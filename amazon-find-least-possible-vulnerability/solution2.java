import java.util.*;

public class Main {
    static int n;
    static int[] key;
    static int[] log2;
    static int[][] st;  // sparse table for gcd

    public static void main(String[] args) {
        // Sample Case 1
        runTest(new int[]{2, 2, 4, 9, 6}, 1, 2);
        // Sample Case 2
        runTest(new int[]{5, 10, 20, 10, 15, 5}, 2, 2);
        // Sample Case 3
        runTest(new int[]{4, 2, 4}, 1, 1);
        // Sample Case 4
        runTest(new int[]{3, 5, 7, 11, 13}, 2, 0);
    }

    static void runTest(int[] arr, int k, int expected) {
        key = arr;
        n   = key.length;
        buildLogs();
        buildSparseTable();
        int ans = findVulnerabilityFactor(k);
        System.out.printf("Input: %s, k=%d → Output: %d   (expected: %d)%n",
                          Arrays.toString(arr), k, ans, expected);
    }

    // 1) Precompute logs for fast lookup
    static void buildLogs() {
        log2 = new int[n+1];
        log2[1] = 0;
        for (int i = 2; i <= n; i++) {
            log2[i] = log2[i/2] + 1;
        }
    }

    // 2) Build sparse‑table st[j][i] = gcd of length‑2^j interval starting at i
    static void buildSparseTable() {
        int K = log2[n] + 1;
        st = new int[K][n];
        // level 0
        for (int i = 0; i < n; i++) {
            st[0][i] = key[i];
        }
        // build up
        for (int j = 1; j < K; j++) {
            int len = 1 << j;
            for (int i = 0; i + len <= n; i++) {
                st[j][i] = gcd(st[j-1][i], st[j-1][i + (len>>1)]);
            }
        }
    }

    // query gcd on [L..R] in O(1)
    static int rangeGCD(int L, int R) {
        int len = R - L + 1;
        int j = log2[len];
        return gcd(st[j][L], st[j][R - (1<<j) + 1]);
    }

    // top‑level binary search
    static int findVulnerabilityFactor(int maxChange) {
        // pre‑check: if no adjacent gcd>1, answer is 0
        boolean anyPair = false;
        for (int i = 0; i+1 < n; i++) {
            if (gcd(key[i], key[i+1]) > 1) {
                anyPair = true;
                break;
            }
        }
        if (!anyPair) return 0;

        int lo = 1, hi = n, ans = n;
        while (lo <= hi) {
            int mid = (lo + hi) >>> 1;
            if (canAchieve(mid, maxChange)) {
                ans = mid;
                hi  = mid - 1;
            } else {
                lo  = mid + 1;
            }
        }
        return ans;
    }

    // check if we can make all GCD>1 runs ≤ T by ≤ k changes
    static boolean canAchieve(int T, int k) {
        int used = 0, lastCover = -1;
        // scan windows of length T+1
        for (int i = 0; i + T < n; i++) {
            if (rangeGCD(i, i+T) > 1) {
                // window [i..i+T] is "bad"
                if (i <= lastCover) continue;    // already broken by a previous change
                used++;
                lastCover = i + T;               // place change at window end
                if (used > k) return false;
            }
        }
        return true;
    }

    // standard gcd
    static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
